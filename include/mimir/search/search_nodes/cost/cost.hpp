#ifndef MIMIR_SEARCH_SEARCH_NODES_COST_HPP_
#define MIMIR_SEARCH_SEARCH_NODES_COST_HPP_


#include "../../../buffer/flatbuffers/search_node-cost_generated.h"

#include "../../states.hpp"
#include "../../actions.hpp"


namespace mimir
{


/**
 * Data types
*/
enum SearchNodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};


/**
 * ID class.
 *
 * Define name and template parameters of your own implementation.
*/
template<IsPlanningModeTag P, IsStateTag S>
class CostSearchNodeTag {};


/**
 * Type traits.
*/
template<IsPlanningModeTag P, IsStateTag S>
struct TypeTraits<Builder<CostSearchNodeTag<P, S>>>
{
    using PlanningModeTag = P;
    using StateTag = S;
};

template<IsPlanningModeTag P, IsStateTag S>
struct TypeTraits<View<CostSearchNodeTag<P, S>>>
{
    using PlanningModeTag = P;
    using StateTag = S;
};


/**
 * Implementation class
*/
template<IsPlanningModeTag P, IsStateTag S>
class Builder<CostSearchNodeTag<P, S>>
    : public IBuilderBase<Builder<CostSearchNodeTag<P, S>>>
{
private:
    using StateView = View<StateDispatcher<S, P>>;
    using ActionView = View<ActionDispatcher<P, S>>;

    flatbuffers::FlatBufferBuilder m_flatbuffers_builder;

    SearchNodeStatus m_status;
    int m_g_value;
    StateView m_parent_state;
    ActionView m_creating_action;

    /* Implement IBuilderBase interface */
    template<typename>
    friend class IBuilderBase;

    void finish_impl() {
        // Genenerate nested data first.
        auto data = CostSearchNodeDataFlat{
                pointer_to_uint64_t(m_parent_state.get_buffer_pointer()),
                pointer_to_uint64_t(m_creating_action.get_buffer_pointer()),
                m_g_value,
                m_status};
        // Generate search node data.
        auto offset = CreateCostSearchNodeFlat(this->m_flatbuffers_builder, &data);
        this->m_flatbuffers_builder.FinishSizePrefixed(offset);
    }

    void clear_impl() {
        m_flatbuffers_builder.Clear();
    }

    [[nodiscard]] uint8_t* get_buffer_pointer_impl() { return m_flatbuffers_builder.GetBufferPointer(); }
    [[nodiscard]] const uint8_t* get_buffer_pointer_impl() const { return m_flatbuffers_builder.GetBufferPointer(); }
    [[nodiscard]] uint32_t get_size_impl() const { return read_value<flatbuffers::uoffset_t>(this->get_buffer_pointer()) + sizeof(flatbuffers::uoffset_t); }

public:
    Builder() : m_parent_state(nullptr), m_creating_action(nullptr) { }

    /// @brief Construct a builder with custom default values.
    Builder(SearchNodeStatus status, int g_value, StateView parent_state, ActionView creating_action)
        : m_status(status), m_g_value(g_value), m_parent_state(parent_state), m_creating_action(creating_action) {
        this->finish();
    }

    void set_status(SearchNodeStatus status) { m_status = status; }
    void set_g_value(int g_value) { m_g_value = g_value; }
    void set_parent_state(StateView parent_state) { m_parent_state = parent_state; }
    void set_ground_action(ActionView creating_action) { m_creating_action = creating_action; }
};


/**
 * Implementation class
 *
 * Reads the memory layout generated by the search node builder.
*/
template<IsPlanningModeTag P, IsStateTag S>
class View<CostSearchNodeTag<P, S>>
    : public IView<View<CostSearchNodeTag<P, S>>>
{
private:
    using StateView = View<StateDispatcher<S, P>>;
    using ActionView = View<ActionDispatcher<P, S>>;

    uint8_t* m_data;
    CostSearchNodeFlat* m_flatbuffers_view;

    /* Implement IView interface: */
    template<typename>
    friend class IView;

    [[nodiscard]] const uint8_t* get_buffer_pointer_impl() const { return m_data; }

    [[nodiscard]] uint32_t get_size_impl() const {
        assert(m_data && m_flatbuffers_view);
        return read_value<flatbuffers::uoffset_t>(m_data) + sizeof(flatbuffers::uoffset_t);
    }

public:
    /// @brief Create a view on a SearchNode.
    explicit View(uint8_t* data)
        : m_data(data)
        , m_flatbuffers_view(data ? GetMutableSizePrefixedCostSearchNodeFlat(reinterpret_cast<void*>(data)) : nullptr) { }

    void set_status(SearchNodeStatus status) {
        assert(m_flatbuffers_view);
        m_flatbuffers_view->mutable_data()->mutate_status(static_cast<uint8_t>(status));
    }

    void set_g_value(int g_value) {
        assert(m_flatbuffers_view);
        m_flatbuffers_view->mutable_data()->mutate_g_value(g_value);
    }

    [[nodiscard]] SearchNodeStatus get_status() {
        assert(m_flatbuffers_view);
        return static_cast<SearchNodeStatus>(m_flatbuffers_view->data()->status());
    }

    [[nodiscard]] int get_g_value() {
        assert(m_flatbuffers_view);
        return m_flatbuffers_view->data()->g_value();
    }

    [[nodiscard]] StateView get_parent_state() {
        assert(m_flatbuffers_view);
        return StateView(uint64_t_to_pointer<uint8_t>(m_flatbuffers_view->data()->state()));
    }

    [[nodiscard]] ActionView get_ground_action() {
        assert(m_flatbuffers_view);
        return ActionView(uint64_t_to_pointer<uint8_t>(m_flatbuffers_view->data()->action()));
    }
};


}

#endif