#ifndef MIMIR_SEARCH_STATES_DENSE_HPP_
#define MIMIR_SEARCH_STATES_DENSE_HPP_

#include "mimir/formalism/ground_atom.hpp"
#include "mimir/formalism/ground_literal.hpp"
#include "mimir/search/flat_types.hpp"
#include "mimir/search/states/interface.hpp"

#include <flatmemory/flatmemory.hpp>

namespace mimir
{
/**
 * Flatmemory types
 */
using FlatDenseStateLayout = flatmemory::Tuple<uint32_t, FlatBitsetLayout>;
using FlatDenseStateBuilder = flatmemory::Builder<FlatDenseStateLayout>;
using FlatDenseState = flatmemory::ConstView<FlatDenseStateLayout>;

struct FlatDenseStateHash
{
    size_t operator()(const FlatDenseState& view) const
    {
        const auto bitset_view = view.get<1>();
        return bitset_view.hash();
    }
};

struct FlatDenseStateEqual
{
    bool operator()(const FlatDenseState& view_left, const FlatDenseState& view_right) const
    {
        const auto bitset_view_left = view_left.get<1>();
        const auto bitset_view_right = view_right.get<1>();
        return bitset_view_left == bitset_view_right;
    }
};

using FlatDenseStateSet = flatmemory::UnorderedSet<FlatDenseStateLayout, FlatDenseStateHash, FlatDenseStateEqual>;

/**
 * Implementation class
 */
template<>
class Builder<StateDispatcher<DenseStateTag>> :
    public IBuilder<Builder<StateDispatcher<DenseStateTag>>>,
    public IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>
{
private:
    FlatDenseStateBuilder m_builder;

    /* Implement IBuilder interface */
    friend class IBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] FlatDenseStateBuilder& get_flatmemory_builder_impl() { return m_builder; }
    [[nodiscard]] const FlatDenseStateBuilder& get_flatmemory_builder_impl() const { return m_builder; }

    /* Implement IStateBuilder interface */
    friend class IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t& get_id_impl() { return m_builder.get<0>(); }

public:
    [[nodiscard]] FlatBitsetBuilder& get_atoms_bitset() { return m_builder.get<1>(); }
};

/**
 * Implementation class
 *
 * Reads the memory layout generated by the lifted state builder.
 */
template<>
class ConstView<StateDispatcher<DenseStateTag>> :
    public IConstView<ConstView<StateDispatcher<DenseStateTag>>>,
    public IStateView<ConstView<StateDispatcher<DenseStateTag>>>
{
private:
    FlatDenseState m_view;

    /* Implement IView interface */
    friend class IConstView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] bool are_equal_impl(const ConstView& other) const { return get_atoms_bitset() == other.get_atoms_bitset(); }

    [[nodiscard]] size_t hash_impl() const { return get_atoms_bitset().hash(); }

    /* Implement IStateView interface */
    friend class IStateView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t get_id_impl() const { return m_view.get<0>(); }

    [[nodiscard]] auto begin_impl() const { return get_atoms_bitset().begin(); }
    [[nodiscard]] auto end_impl() const { return get_atoms_bitset().end(); }

public:
    explicit ConstView(FlatDenseState view) : m_view(view) {}

    [[nodiscard]] FlatBitset get_atoms_bitset() const { return m_view.get<1>(); }

    bool contains(const GroundAtom& ground_atom) const { return get_atoms_bitset().get(ground_atom->get_identifier()); }

    bool literal_holds(const GroundLiteral& literal) const { return literal->is_negated() != contains(literal->get_atom()); }

    bool literals_hold(const GroundLiteralList& literals) const
    {
        for (const auto& literal : literals)
        {
            if (!literal_holds(literal))
            {
                return false;
            }
        }

        return true;
    }
};

/**
 * Mimir types
 */
using DenseStateBuilder = Builder<StateDispatcher<DenseStateTag>>;
using DenseState = ConstView<StateDispatcher<DenseStateTag>>;
}

#endif
