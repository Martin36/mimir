/*
 * Copyright (C) 2023 Dominik Drexler and Simon Stahlberg
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MIMIR_SEARCH_STATES_DENSE_HPP_
#define MIMIR_SEARCH_STATES_DENSE_HPP_

#include "mimir/common/printers.hpp"
#include "mimir/formalism/formalism.hpp"
#include "mimir/search/flat_types.hpp"
#include "mimir/search/states/interface.hpp"

#include <flatmemory/flatmemory.hpp>
#include <ostream>
#include <tuple>

namespace mimir
{
/**
 * Flatmemory types
 */
using FlatDenseStateLayout = flatmemory::Tuple<uint32_t, FlatBitsetLayout<Fluent>, FlatBitsetLayout<Derived>, Problem>;
using FlatDenseStateBuilder = flatmemory::Builder<FlatDenseStateLayout>;
using FlatDenseState = flatmemory::ConstView<FlatDenseStateLayout>;

// Only hash/compare the non-extended portion of a state, and the problem.
// The extended portion is computed automatically, when calling ssg.create_state(...)
struct FlatDenseStateHash
{
    size_t operator()(const FlatDenseState& view) const
    {
        const auto fluent_atoms = view.get<1>();
        const auto problem = view.get<3>();
        return loki::hash_combine(fluent_atoms.hash(), problem);
    }
};

struct FlatDenseStateEqual
{
    bool operator()(const FlatDenseState& view_left, const FlatDenseState& view_right) const
    {
        const auto fluent_atoms_left = view_left.get<1>();
        const auto fluent_atoms_right = view_right.get<1>();
        const auto problem_left = view_left.get<3>();
        const auto problem_right = view_right.get<3>();
        return (fluent_atoms_left == fluent_atoms_right) && (problem_left == problem_right);
    }
};

using FlatDenseStateSet = flatmemory::UnorderedSet<FlatDenseStateLayout, FlatDenseStateHash, FlatDenseStateEqual>;
using FlatDenseStateVector = flatmemory::FixedSizedTypeVector<FlatDenseStateLayout>;

/**
 * Implementation class
 */
/**
 * Implementation class
 */
template<>
class Builder<StateDispatcher<DenseStateTag>> :
    public IBuilder<Builder<StateDispatcher<DenseStateTag>>>,
    public IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>
{
private:
    FlatDenseStateBuilder m_builder;

    /* Implement IBuilder interface */
    friend class IBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] FlatDenseStateBuilder& get_flatmemory_builder_impl() { return m_builder; }
    [[nodiscard]] const FlatDenseStateBuilder& get_flatmemory_builder_impl() const { return m_builder; }

    /* Implement IStateBuilder interface */
    friend class IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t& get_id_impl() { return m_builder.get<0>(); }

public:
    [[nodiscard]] FlatBitsetBuilder<Fluent>& get_fluent_atoms() { return m_builder.get<1>(); }
    [[nodiscard]] FlatBitsetBuilder<Derived>& get_derived_atoms() { return m_builder.get<2>(); }
    [[nodiscard]] Problem& get_problem() { return m_builder.get<3>(); }
};

/**
 * Implementation class
 *
 * Reads the memory layout generated by the lifted state builder.
 */
template<>
class ConstView<StateDispatcher<DenseStateTag>> :
    public IConstView<ConstView<StateDispatcher<DenseStateTag>>>,
    public IStateView<ConstView<StateDispatcher<DenseStateTag>>>
{
private:
    FlatDenseState m_view;

    /* Implement IView interface */
    friend class IConstView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] bool are_equal_impl(const ConstView& other) const { return get_fluent_atoms() == other.get_fluent_atoms(); }

    [[nodiscard]] size_t hash_impl() const { return get_fluent_atoms().hash(); }

    /* Implement IStateView interface */
    friend class IStateView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t get_id_impl() const { return m_view.get<0>(); }

    [[nodiscard]] auto begin_impl() const { return get_fluent_atoms().begin(); }
    [[nodiscard]] auto end_impl() const { return get_fluent_atoms().end(); }

public:
    explicit ConstView(FlatDenseState view) : m_view(view) {}

    [[nodiscard]] FlatBitset<Fluent> get_fluent_atoms() const { return m_view.get<1>(); }
    [[nodiscard]] FlatBitset<Derived> get_derived_atoms() const { return m_view.get<2>(); }
    [[nodiscard]] Problem get_problem() const { return m_view.get<3>(); }

    bool contains(const GroundAtom<Static>& ground_atom) const
    {
        return get_problem()->get_static_initial_positive_atoms_bitset().get(ground_atom->get_identifier());
    }

    bool contains(const GroundAtom<Fluent>& ground_atom) const { return get_fluent_atoms().get(ground_atom->get_identifier()); }

    bool contains(const GroundAtom<Derived>& ground_atom) const { return get_derived_atoms().get(ground_atom->get_identifier()); }

    template<PredicateCategory P>
    bool literal_holds(const GroundLiteral<P>& literal) const
    {
        return literal->is_negated() != contains(literal->get_atom());
    }

    template<PredicateCategory P>
    bool literals_hold(const GroundLiteralList<P>& literals) const
    {
        for (const auto& literal : literals)
        {
            if (!literal_holds(literal))
            {
                return false;
            }
        }

        return true;
    }
};

/**
 * Mimir types
 */

using DenseStateBuilder = Builder<StateDispatcher<DenseStateTag>>;
using DenseState = ConstView<StateDispatcher<DenseStateTag>>;
using DenseStateList = std::vector<DenseState>;

struct DenseStateHash
{
    size_t operator()(const DenseState& view) const { return view.hash(); }
};

using DenseStateSet = std::unordered_set<DenseState, DenseStateHash>;

/**
 * Pretty printing
 */

extern std::ostream& operator<<(std::ostream& os, const std::tuple<DenseState, const PDDLFactories&>& data);

}

#endif
