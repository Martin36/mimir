#ifndef MIMIR_SEARCH_STATES_DENSE_HPP_
#define MIMIR_SEARCH_STATES_DENSE_HPP_

#include "mimir/formalism/ground_atom.hpp"
#include "mimir/formalism/ground_literal.hpp"
#include "mimir/search/states/interface.hpp"
#include "mimir/search/type_traits.hpp"
#include "mimir/search/types.hpp"

#include <flatmemory/flatmemory.hpp>

/**
 * Flatmemory types
 */
namespace flat
{
using DenseStateLayout = flatmemory::Tuple<uint32_t, BitsetLayout>;
using DenseStateBuilder = flatmemory::Builder<DenseStateLayout>;
using DenseState = flatmemory::ConstView<DenseStateLayout>;

struct DenseStateHash
{
    size_t operator()(const DenseState& view) const
    {
        const auto bitset_view = view.get<1>();
        return bitset_view.hash();
    }
};

struct DenseStateEqual
{
    bool operator()(const DenseState& view_left, const DenseState& view_right) const
    {
        const auto bitset_view_left = view_left.get<1>();
        const auto bitset_view_right = view_right.get<1>();
        return bitset_view_left == bitset_view_right;
    }
};

using DenseStateSet = flatmemory::UnorderedSet<DenseStateLayout, DenseStateHash, DenseStateEqual>;
}

namespace mimir
{
/**
 * Derived ID class.
 *
 * Define name and template parameters of your own implementation.
 */
class DenseStateTag : public StateTag
{
};

/**
 * Implementation class
 */
template<>
class Builder<StateDispatcher<DenseStateTag>> :
    public IBuilder<Builder<StateDispatcher<DenseStateTag>>>,
    public IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>
{
private:
    flat::DenseStateBuilder m_builder;

    /* Implement IBuilder interface */
    friend class IBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] flat::DenseStateBuilder& get_flatmemory_builder_impl() { return m_builder; }
    [[nodiscard]] const flat::DenseStateBuilder& get_flatmemory_builder_impl() const { return m_builder; }

    /* Implement IStateBuilder interface */
    friend class IStateBuilder<Builder<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t& get_id_impl() { return m_builder.get<0>(); }

public:
    [[nodiscard]] flat::BitsetBuilder& get_atoms_bitset() { return m_builder.get<1>(); }
};

/**
 * Implementation class
 *
 * Reads the memory layout generated by the lifted state builder.
 */
template<>
class ConstView<StateDispatcher<DenseStateTag>> :
    public IConstView<ConstView<StateDispatcher<DenseStateTag>>>,
    public IStateView<ConstView<StateDispatcher<DenseStateTag>>>
{
private:
    flat::DenseState m_view;

    /* Implement IView interface */
    friend class IConstView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] bool are_equal_impl(const ConstView& other) const { return get_atoms_bitset() == other.get_atoms_bitset(); }

    [[nodiscard]] size_t hash_impl() const { return get_atoms_bitset().hash(); }

    /* Implement IStateView interface */
    friend class IStateView<ConstView<StateDispatcher<DenseStateTag>>>;

    [[nodiscard]] uint32_t get_id_impl() const { return m_view.get<0>(); }

    [[nodiscard]] auto begin_impl() const { return get_atoms_bitset().begin(); }
    [[nodiscard]] auto end_impl() const { return get_atoms_bitset().end(); }

public:
    explicit ConstView(flat::DenseState view) : m_view(view) {}

    [[nodiscard]] flat::Bitset get_atoms_bitset() const { return m_view.get<1>(); }

    bool contains(const GroundAtom& ground_atom) const { return get_atoms_bitset().get(ground_atom->get_identifier()); }

    bool literal_holds(const GroundLiteral& literal) const { return literal->is_negated() != contains(literal->get_atom()); }

    bool literals_hold(const GroundLiteralList& literals) const
    {
        for (const auto& literal : literals)
        {
            if (!literal_holds(literal))
            {
                return false;
            }
        }

        return true;
    }
};

/**
 * Mimir types
 */
using DenseStateBuilder = Builder<StateDispatcher<DenseStateTag>>;
using DenseState = ConstView<StateDispatcher<DenseStateTag>>;

}

#endif
